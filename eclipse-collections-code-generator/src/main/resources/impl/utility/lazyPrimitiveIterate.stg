import "copyrightAndOthers.stg"

targetPath() ::= "org/eclipse/collections/impl/utility/primitive"

fileName(primitive) ::= "Lazy<primitive.name>Iterate"

class(primitive) ::= <<
<body(primitive.type, primitive.name)>
>>

body(type, name) ::= <<
<copyrightAndOthers()>

package org.eclipse.collections.impl.utility.primitive;

import org.eclipse.collections.api.<name>Iterable;
import org.eclipse.collections.api.Lazy<name>Iterable;
import org.eclipse.collections.api.LazyIterable;
import org.eclipse.collections.api.block.function.primitive.<name>ToObjectFunction;
import org.eclipse.collections.api.block.predicate.primitive.<name>Predicate;
import org.eclipse.collections.api.block.procedure.primitive.<name>Procedure;
import org.eclipse.collections.impl.factory.primitive.<name>Lists;
import org.eclipse.collections.impl.lazy.primitive.Collect<name>ToObjectIterable;
import org.eclipse.collections.impl.lazy.primitive.FlatCollect<name>ToObjectIterable;
import org.eclipse.collections.impl.lazy.primitive.Lazy<name>IterableAdapter;
import org.eclipse.collections.impl.lazy.primitive.Select<name>Iterable;
import org.eclipse.collections.impl.lazy.primitive.Tap<name>Iterable;

/**
 * Lazy<name>Iterate is a factory class which creates "deferred" <type> iterables around the specified <type> iterables. A "deferred"
 * <type> iterable performs some operation, such as filtering or transforming, when the result <type> iterable is iterated over.  This
 * makes the operation very memory efficient, because you don't have to create intermediate collections during the
 * operation.
 * This file was automatically generated from template file lazyPrimitiveIterate.stg.
 *
 * @since 5.0
 */
public final class Lazy<name>Iterate
{
    private static final Lazy<name>Iterable EMPTY_ITERABLE = <name>Lists.immutable.empty().asLazy();

    private Lazy<name>Iterate()
    {
        throw new AssertionError("Suppress default constructor for noninstantiability");
    }

    /**
     * Creates a deferred <type> iterable for the specified <type> iterable.
     */
    public static Lazy<name>Iterable adapt(<name>Iterable iterable)
    {
        return new Lazy<name>IterableAdapter(iterable);
    }

    /**
     * Creates a deferred filtering <type> iterable for the specified <type> iterable.
     */
    public static Lazy<name>Iterable select(<name>Iterable iterable, <name>Predicate predicate)
    {
        return new Select<name>Iterable(iterable, predicate);
    }

    /**
     * Creates a deferred transforming <type> iterable for the specified <type> iterable.
     */
    public static \<V> LazyIterable\<V> collect(
            <name>Iterable iterable,
            <name>ToObjectFunction\<? extends V> function)
    {
        return new Collect<name>ToObjectIterable\<>(iterable, function);
    }

    /**
     * Creates a deferred transforming and flattening <type> iterable for the specified <type> iterable.
     *
     * @since 9.0
     */
    public static \<V> LazyIterable\<V> flatCollect(
            <name>Iterable iterable,
            <name>ToObjectFunction\<? extends Iterable\<V>\> function)
    {
        return new FlatCollect<name>ToObjectIterable\<>(iterable, function);
    }

    /**
     * Creates a deferred filtering and transforming <type> iterable for the specified <type> iterable.
     */
    public static \<V> LazyIterable\<V> collectIf(
            <name>Iterable iterable,
            <name>Predicate predicate,
            <name>ToObjectFunction\<? extends V> function)
    {
        return Lazy<name>Iterate.select(iterable, predicate).collect(function);
    }

    public static Lazy<name>Iterable empty()
    {
        return EMPTY_ITERABLE;
    }

    /**
     * Creates a deferred tap iterable for the specified iterable.
     *
     * @since 9.0
     */
    public static Lazy<name>Iterable tap(<name>Iterable iterable, <name>Procedure procedure)
    {
        return new Tap<name>Iterable(iterable, procedure);
    }
}

>>
