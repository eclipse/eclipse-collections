import "copyrightAndOthers.stg"
import "primitiveHashCode.stg"
import "primitiveLiteral.stg"

isTest() ::= "true"

targetPath() ::= "org/eclipse/collections/impl/map/primitive"

fileName(primitive) ::= "Abstract<primitive.name>ObjectMapTestCase"

skipBoolean() ::= "true"

class(primitive) ::= <<
<body(primitive.type, primitive.name)>
>>

body(type, name) ::= <<
<copyrightAndOthers()>

package org.eclipse.collections.impl.map.primitive;

import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.collections.api.RichIterable;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function0;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.function.primitive.DoubleFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleObjectToDoubleFunction;
import org.eclipse.collections.api.block.function.primitive.FloatFunction;
import org.eclipse.collections.api.block.function.primitive.FloatObjectToFloatFunction;
import org.eclipse.collections.api.block.function.primitive.IntFunction;
import org.eclipse.collections.api.block.function.primitive.IntObjectToIntFunction;
import org.eclipse.collections.api.block.function.primitive.LongFunction;
import org.eclipse.collections.api.block.function.primitive.LongObjectToLongFunction;
import org.eclipse.collections.api.block.predicate.Predicate;
import org.eclipse.collections.api.block.predicate.Predicate2;
import org.eclipse.collections.api.block.predicate.primitive.<name>ObjectPredicate;
import org.eclipse.collections.api.block.procedure.Procedure2;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.map.MapIterable;
import org.eclipse.collections.api.map.primitive.Immutable<name>ObjectMap;
import org.eclipse.collections.api.map.primitive.Mutable<name>ObjectMap;
import org.eclipse.collections.api.map.primitive.<name>ObjectMap;
import org.eclipse.collections.api.map.primitive.ObjectDoubleMap;
import org.eclipse.collections.api.map.primitive.ObjectLongMap;
import org.eclipse.collections.api.multimap.Multimap;
import org.eclipse.collections.api.partition.PartitionIterable;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.api.tuple.Pair;
import org.eclipse.collections.impl.bag.mutable.HashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.BooleanHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.ByteHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.CharHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.DoubleHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.FloatHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.IntHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.LongHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.ShortHashBag;
import org.eclipse.collections.impl.bag.sorted.mutable.TreeBag;
import org.eclipse.collections.impl.block.factory.Comparators;
import org.eclipse.collections.impl.block.factory.Functions;
import org.eclipse.collections.impl.block.factory.Functions0;
import org.eclipse.collections.impl.block.factory.Predicates;
import org.eclipse.collections.impl.block.factory.Predicates2;
import org.eclipse.collections.impl.block.factory.Procedures;
import org.eclipse.collections.impl.block.factory.StringFunctions;
import org.eclipse.collections.impl.block.factory.StringPredicates;
import org.eclipse.collections.impl.block.factory.StringPredicates2;
import org.eclipse.collections.impl.factory.primitive.<name>ObjectMaps;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.list.mutable.primitive.<name>ArrayList;
import org.eclipse.collections.impl.map.mutable.UnifiedMap;
import org.eclipse.collections.impl.map.mutable.primitive.<name>ObjectHashMap;
import org.eclipse.collections.impl.map.mutable.primitive.<name>ObjectHashMapTest;
import org.eclipse.collections.impl.multimap.list.FastListMultimap;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;
import org.eclipse.collections.impl.set.mutable.primitive.<name>HashSet;
import org.eclipse.collections.impl.set.sorted.mutable.TreeSortedSet;
import org.eclipse.collections.impl.string.immutable.CharAdapter;
import org.eclipse.collections.impl.test.Verify;
import org.eclipse.collections.impl.tuple.Tuples;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertNull;

/**
 * This file was automatically generated from template file abstractPrimitiveObjectMapTestCase.stg.
 */
public abstract class Abstract<name>ObjectMapTestCase
{
    protected abstract <name>ObjectMap\<String> classUnderTest();

    protected abstract \<T> <name>ObjectMap\<T> newWithKeysValues(<type> key1, T value1);

    protected abstract \<T> <name>ObjectMap\<T> newWithKeysValues(<type> key1, T value1, <type> key2, T value2);

    protected abstract \<T> <name>ObjectMap\<T> newWithKeysValues(<type> key1, T value1, <type> key2, T value2, <type> key3, T value3);

    protected abstract \<T> <name>ObjectMap\<T> getEmptyMap();

    @Test
    public void keySet()
    {
        Verify.assertEmpty(this.getEmptyMap().keySet());
        assertEquals(<name>HashSet.newSetWith(<(literal.(type))("0")>), this.newWithKeysValues(<(literal.(type))("0")>, "zero").keySet());
        assertEquals(<name>HashSet.newSetWith(<(literal.(type))("0")>, <(literal.(type))("1")>, <(literal.(type))("9")>),
                this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine").keySet());
    }

    @Test
    public void values()
    {
        Verify.assertEmpty(this.getEmptyMap().values());

        <name>ObjectMap\<String> map = this.newWithKeysValues(<(literal.(type))("0")>, "zero");
        Verify.assertSize(1, map.values());
        Verify.assertContains("zero", map.values());

        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Verify.assertSize(3, map1.values());
        Verify.assertContainsAll(map1.values(), "zero", "one", "nine");
    }

    @Test
    public void select()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine"),
                map1.select((<type> value, String object) -> (value % 2) != 0));

        <name>ObjectPredicate\<String> keyGreaterThanOrEqualToSeven = (<type> value, String object) -> value \<= 7;

        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one"), map1.select(keyGreaterThanOrEqualToSeven));

        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero"), map2.select(keyGreaterThanOrEqualToSeven));

        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one"), map3.select(keyGreaterThanOrEqualToSeven));

        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("5")>, "five"), map4.select(keyGreaterThanOrEqualToSeven));

        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine"),
                map1.select((<type> value, String object) -> object.endsWith("ne")));

        RichIterable\<String> actual1 = map1.select(StringPredicates.endsWith("ne"));
        assertTrue(HashBag.newBagWith("one", "nine").equals(actual1));

        assertEquals(HashBag.newBagWith("nine"), map1.select(Predicates.equal("nine")));

        assertEquals(HashBag.newBagWith("zero"), map1.select(StringPredicates.endsWith("o")));

        assertEquals(HashBag.newBagWith("nine"), map1.select(Predicates.equal("nine"), HashBag.\<String>newBag()));

        assertEquals(HashBag.newBagWith("one", "nine"), map1.select(StringPredicates.endsWith("ne"), HashBag.\<String>newBag()));

        assertEquals(HashBag.newBagWith("zero"), map1.select(StringPredicates.endsWith("o"), HashBag.\<String>newBag()));
    }

    @Test
    public void selectWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("one", "nine"), map1.selectWith(StringPredicates2.endsWith(), "ne"));

        assertEquals(HashBag.newBagWith("nine"), map1.selectWith(Object::equals, "nine"));

        assertEquals(HashBag.newBagWith("zero"), map1.selectWith(StringPredicates2.endsWith(), "o"));
    }

    @Test
    public void selectWith_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("one", "nine"), map1.selectWith(StringPredicates2.endsWith(), "ne", HashBag.\<String>newBag()));

        assertEquals(HashBag.newBagWith("nine"), map1.selectWith(Object::equals, "nine", HashBag.\<String>newBag()));

        assertEquals(HashBag.newBagWith("zero"), map1.selectWith(StringPredicates2.endsWith(), "o", HashBag.\<String>newBag()));
    }

    @Test
    public void selectInstancesOf()
    {
        <name>ObjectMap\<Number> numbers = this.\<Number>newWithKeysValues(<(literal.(type))("0")>, 0, <(literal.(type))("1")>, 1.0, <(literal.(type))("5")>, 5.0);

        assertEquals(HashBag.newBagWith(0), numbers.selectInstancesOf(Integer.class));
        assertEquals(HashBag.newBagWith(1.0, 5.0), numbers.selectInstancesOf(Double.class));
    }

    @Test
    public void collect()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("ZERO", "ONE", "NINE"), map1.collect(StringFunctions.toUpperCase()));
        assertEquals(HashBag.newBagWith("ZERO", "ONE", "NINE"), map1.collect(StringFunctions.toUpperCase(), HashBag.\<String>newBag()));
    }

    @Test
    public void collectBoolean()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "true", <(literal.(type))("1")>, "false", <(literal.(type))("2")>, "nah");

        assertEquals(BooleanHashBag.newBagWith(true, false, false), map1.collectBoolean(StringFunctions.toPrimitiveBoolean()));
    }

    @Test
    public void collectBoolean_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "true", <(literal.(type))("1")>, "false", <(literal.(type))("2")>, "nah");
        BooleanHashBag target = new BooleanHashBag();
        assertSame(target, map1.collectBoolean(StringFunctions.toPrimitiveBoolean(), target));
        assertEquals(BooleanHashBag.newBagWith(true, false, false), target);
    }

    @Test
    public void collectByte()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");

        assertEquals(ByteHashBag.newBagWith((byte) 0, (byte) 1, (byte) 9), map1.collectByte(Byte::parseByte));
    }

    @Test
    public void collectByte_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");
        ByteHashBag target = new ByteHashBag();
        assertSame(target, map1.collectByte(Byte::parseByte, target));
        assertEquals(ByteHashBag.newBagWith((byte) 0, (byte) 1, (byte) 9), target);
    }

    @Test
    public void collectChar()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");

        assertEquals(CharHashBag.newBagWith((char) 0, (char) 1, (char) 9), map1.collectChar(StringFunctions.toPrimitiveChar()));
    }

    @Test
    public void collectChar_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");
        CharHashBag target = new CharHashBag();
        assertSame(target, map1.collectChar(StringFunctions.toPrimitiveChar(), target));
        assertEquals(CharHashBag.newBagWith((char) 0, (char) 1, (char) 9), target);
    }

    @Test
    public void collectDouble()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");

        assertEquals(DoubleHashBag.newBagWith(0.0d, 1.0d, 9.0d), map1.collectDouble(Double::parseDouble));
    }

    @Test
    public void collectDouble_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");
        DoubleHashBag target = new DoubleHashBag();
        assertSame(target, map1.collectDouble(Double::parseDouble, target));
        assertEquals(DoubleHashBag.newBagWith(0.0d, 1.0d, 9.0d), target);
    }

    @Test
    public void collectFloat()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");

        assertEquals(FloatHashBag.newBagWith(0.0f, 1.0f, 9.0f), map1.collectFloat(Float::parseFloat));
    }

    @Test
    public void collectFloat_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");
        FloatHashBag target = new FloatHashBag();
        assertSame(target, map1.collectFloat(Float::parseFloat, target));
        assertEquals(FloatHashBag.newBagWith(0.0f, 1.0f, 9.0f), target);
    }

    @Test
    public void collectInt()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");

        assertEquals(IntHashBag.newBagWith(0, 1, 9), map1.collectInt(Integer::parseInt));
    }

    @Test
    public void collectInt_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");
        IntHashBag target = new IntHashBag();
        assertSame(target, map1.collectInt(Integer::parseInt, target));
        assertEquals(IntHashBag.newBagWith(0, 1, 9), target);
    }

    @Test
    public void collectLong()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");

        assertEquals(LongHashBag.newBagWith(0L, 1L, 9L), map1.collectLong(Long::parseLong));
    }

    @Test
    public void collectLong_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");
        LongHashBag target = new LongHashBag();
        assertSame(target, map1.collectLong(Long::parseLong, target));
        assertEquals(LongHashBag.newBagWith(0L, 1L, 9L), target);
    }

    @Test
    public void collectShort()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");

        assertEquals(ShortHashBag.newBagWith((short) 0, (short) 1, (short) 9), map1.collectShort(Short::parseShort));
    }

    @Test
    public void collectShort_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "0", <(literal.(type))("1")>, "1", <(literal.(type))("2")>, "9");
        ShortHashBag target = new ShortHashBag();
        assertSame(target, map1.collectShort(Short::parseShort, target));
        assertEquals(ShortHashBag.newBagWith((short) 0, (short) 1, (short) 9), target);
    }

    @Test
    public void collectWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("ZERO!", "ONE!", "NINE!"),
                map1.collectWith((String argument1, String argument2) -> argument1.toUpperCase() + argument2, "!"));
    }

    @Test
    public void collectWithTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("ZERO!", "ONE!", "NINE!"),
                map1.collectWith((String argument1, String argument2) -> argument1.toUpperCase() + argument2, "!", HashBag.\<String>newBag()));
    }

    @Test
    public void collectIf()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("ONE", "NINE"), map1.collectIf(StringPredicates.endsWith("ne"), StringFunctions.toUpperCase()));
        assertEquals(HashBag.newBagWith("ZERO"), map1.collectIf(StringPredicates.endsWith("o"), StringFunctions.toUpperCase()));
        assertEquals(HashBag.newBagWith("ZERO"), map1.collectIf(StringPredicates.endsWith("o"), StringFunctions.toUpperCase(), HashBag.\<String>newBag()));
    }

    @Test
    public void flatCollect()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        Function\<String, MutableList\<Character>\> toChars = (String object) ->
        {
            MutableList\<Character> list = FastList.newList();
            char[] chars = object.toCharArray();
            for (char aChar : chars)
            {
                list.add(aChar);
            }
            return list;
        };

        assertEquals(UnifiedSet.newSetWith('z', 'e', 'r', 'o', 'n', 'i'), map1.flatCollect(toChars).toSet());
        assertEquals(UnifiedSet.newSetWith('o', 'n', 'e', 'i'), map2.flatCollect(toChars).toSet());
        assertEquals(UnifiedSet.newSetWith('f', 'i', 'v', 'e', 'n'), map3.flatCollect(toChars).toSet());
        assertEquals(UnifiedSet.newSetWith('f', 'i', 'v', 'e', 'n'), map3.flatCollect(toChars, UnifiedSet.\<Character>newSet()));
    }

    @Test
    public void detect()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        assertTrue("one".equals(map1.detect(StringPredicates.endsWith("ne"))) || "nine".equals(map1.detect(StringPredicates.endsWith("ne"))));
        assertEquals("zero", map1.detect(StringPredicates.endsWith("o")));
        assertEquals("nine", map1.detect(Predicates.equal("nine")));
        assertNull(map1.detect(Predicates.equal("ten")));
    }

    @Test
    public void detectWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        assertTrue("one".equals(map1.detectWith(StringPredicates2.endsWith(), "ne")) || "nine".equals(map1.detectWith(StringPredicates2.endsWith(), "ne")));
        assertEquals("zero", map1.detectWith(StringPredicates2.endsWith(), "o"));
        assertEquals("nine", map1.detectWith(Object::equals, "nine"));
        assertNull(map1.detectWith(Object::equals, "ten"));
    }

    @Test
    public void detectOptional()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        assertTrue(Optional.of("one").equals(map1.detectOptional(StringPredicates.endsWith("ne"))) || Optional.of("nine").equals(map1.detectOptional(StringPredicates.endsWith("ne"))));
        assertEquals(Optional.of("zero"), map1.detectOptional(StringPredicates.endsWith("o")));
        assertEquals(Optional.of("nine"), map1.detectOptional(Predicates.equal("nine")));
        assertEquals(Optional.empty(), map1.detectOptional(Predicates.equal("ten")));
    }

    @Test
    public void detectWithOptional()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        assertTrue(Optional.of("one").equals(map1.detectWithOptional(StringPredicates2.endsWith(), "ne")) || Optional.of("nine").equals(map1.detectWithOptional(StringPredicates2.endsWith(), "ne")));
        assertEquals(Optional.of("zero"), map1.detectWithOptional(StringPredicates2.endsWith(), "o"));
        assertEquals(Optional.of("nine"), map1.detectWithOptional(Object::equals, "nine"));
        assertEquals(Optional.empty(), map1.detectWithOptional(Object::equals, "ten"));
    }

    @Test
    public void detectIfNone()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Function0\<String> ifNone = () -> "ifNone";
        assertTrue("one".equals(map1.detectIfNone(StringPredicates.endsWith("ne"), ifNone))
                || "nine".equals(map1.detectIfNone(StringPredicates.endsWith("ne"), ifNone)));
        assertEquals("zero", map1.detectIfNone(StringPredicates.endsWith("o"), ifNone));
        assertEquals("nine", map1.detectIfNone(Predicates.equal("nine"), ifNone));
        assertEquals("ifNone", map1.detectIfNone(Predicates.equal("ten"), ifNone));
    }

    @Test
    public void detectWithIfNone()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Function0\<String> ifNone = () -> "ifNone";
        assertTrue("one".equals(map1.detectWithIfNone(StringPredicates2.endsWith(), "ne", ifNone))
                || "nine".equals(map1.detectWithIfNone(StringPredicates2.endsWith(), "ne", ifNone)));
        assertEquals("zero", map1.detectWithIfNone(StringPredicates2.endsWith(), "o", ifNone));
        assertEquals("nine", map1.detectWithIfNone(Object::equals, "nine", ifNone));
        assertEquals("ifNone", map1.detectWithIfNone(Object::equals, "ten", ifNone));
    }

    @Test
    public void count()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Verify.assertCount(2, map1, StringPredicates.endsWith("ne"));
        Verify.assertCount(1, map1, StringPredicates.endsWith("o"));
        Verify.assertCount(1, map1, Predicates.equal("nine"));
        Verify.assertCount(0, map1, Predicates.equal("ten"));
    }

    @Test
    public void countWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertEquals(2, map1.countWith(StringPredicates2.endsWith(), "ne"));
        assertEquals(1, map1.countWith(StringPredicates2.endsWith(), "o"));
        assertEquals(1, map1.countWith(Object::equals, "nine"));
        assertNotEquals(1, map1.countWith(Object::equals, "ten"));
    }

    @Test
    public void anySatisfy()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Verify.assertAnySatisfy(map1, StringPredicates.endsWith("ne"));
        Verify.assertAnySatisfy(map1, StringPredicates.endsWith("o"));
        Verify.assertAnySatisfy(map1, Predicates.equal("nine"));
        assertFalse(map1.anySatisfy(Predicates.equal("ten")));
    }

    @Test
    public void anySatisfyWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        assertTrue(map1.anySatisfyWith(StringPredicates2.endsWith(), "ne"));
        assertTrue(map1.anySatisfyWith(StringPredicates2.endsWith(), "o"));
        assertTrue(map1.anySatisfyWith(Object::equals, "nine"));
        assertFalse(map1.anySatisfyWith(Object::equals, "ten"));
    }

    @Test
    public void allSatisfy()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertTrue(map1.allSatisfy(StringPredicates.contains("e")));
        assertFalse(map1.allSatisfy(StringPredicates.endsWith("o")));
        assertFalse(map1.allSatisfy(StringPredicates.contains("o")));
        assertFalse(map1.allSatisfy(Predicates.equal("nine")));
        assertFalse(map1.allSatisfy(Predicates.equal("ten")));
    }

    @Test
    public void allSatisfyWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertTrue(map1.allSatisfyWith(StringPredicates2.contains(), "e"));
        assertFalse(map1.allSatisfyWith(StringPredicates2.endsWith(), "o"));
        assertFalse(map1.allSatisfyWith(StringPredicates2.contains(), "o"));
        assertFalse(map1.allSatisfyWith(Object::equals, "nine"));
        assertFalse(map1.allSatisfyWith(Object::equals, "ten"));
    }

    @Test
    public void noneSatisfy()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertTrue(map1.noneSatisfy(StringPredicates.notContains("e")));
        assertFalse(map1.noneSatisfy(StringPredicates.endsWith("o")));
        assertFalse(map1.noneSatisfy(StringPredicates.startsWith("o")));
        assertFalse(map1.noneSatisfy(StringPredicates.contains("o")));
        assertFalse(map1.noneSatisfy(Predicates.equal("nine")));
        assertTrue(map1.noneSatisfy(Predicates.equal("ten")));
    }

    @Test
    public void noneSatisfyWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertTrue(map1.noneSatisfyWith(StringPredicates2.notContains(), "e"));
        assertFalse(map1.noneSatisfyWith(StringPredicates2.endsWith(), "o"));
        assertFalse(map1.noneSatisfyWith(StringPredicates2.startsWith(), "o"));
        assertFalse(map1.noneSatisfyWith(StringPredicates2.contains(), "o"));
        assertFalse(map1.noneSatisfyWith(Object::equals, "nine"));
        assertTrue(map1.noneSatisfyWith(Object::equals, "ten"));
    }

    @Test
    public void injectInto()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        Function2\<String, String, String> concat = (String argument1, String argument2) -> argument1 + '-' + argument2;

        assertTrue("Start-zero-nine".equals(map1.injectInto("Start", concat))
                || "Start-nine-zero".equals(map1.injectInto("Start", concat)));
        assertTrue("Start-one-nine".equals(map2.injectInto("Start", concat))
                || "Start-nine-one".equals(map2.injectInto("Start", concat)));
        assertTrue("Start-five-nine".equals(map3.injectInto("Start", concat))
                || "Start-nine-five".equals(map3.injectInto("Start", concat)));
    }

    @Test
    public void intInjectInto()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        IntObjectToIntFunction\<String> function = (int intParameter, String objectParameter) -> intParameter + objectParameter.length();
        assertEquals(6, map1.injectInto(1, function));
        assertEquals(7, map2.injectInto(1, function));
        assertEquals(8, map3.injectInto(1, function));
    }

    @Test
    public void longInjectInto()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        LongObjectToLongFunction\<String> function = (long longParameter, String objectParameter) -> longParameter + objectParameter.length();
        assertEquals(6L, map1.injectInto(1L, function));
        assertEquals(7L, map2.injectInto(1L, function));
        assertEquals(8L, map3.injectInto(1L, function));
    }

    @Test
    public void floatInjectInto()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        FloatObjectToFloatFunction\<String> function = (float floatParameter, String objectParameter) -> floatParameter + objectParameter.length();
        assertEquals(6.0f, map1.injectInto(1.0f, function), 0.0);
        assertEquals(7.0f, map2.injectInto(1.0f, function), 0.0);
        assertEquals(8.0f, map3.injectInto(1.0f, function), 0.0);
    }

    @Test
    public void doubleInjectInto()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        DoubleObjectToDoubleFunction\<String> function = (double doubleParameter, String objectParameter) -> doubleParameter + objectParameter.length();
        assertEquals(6.0, map1.injectInto(1.0, function), 0.0);
        assertEquals(7.0, map2.injectInto(1.0, function), 0.0);
        assertEquals(8.0, map3.injectInto(1.0, function), 0.0);
    }

    @Test
    public void toList()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        assertTrue(FastList.newListWith("zero", "nine").equals(map1.toList())
                || FastList.newListWith("nine", "zero").equals(map1.toList()), map1.toList().toString());
        assertTrue(FastList.newListWith("one", "nine").equals(map2.toList())
                || FastList.newListWith("nine", "one").equals(map2.toList()), map2.toList().toString());
        assertTrue(FastList.newListWith("five", "nine").equals(map3.toList())
                || FastList.newListWith("nine", "five").equals(map3.toList()), map3.toList().toString());
    }

    @Test
    public void toSortedList()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(
                FastList.newListWith("nine", "zero"), map1.toSortedList(), map1.toSortedList().toString());
        assertEquals(
                FastList.newListWith("nine", "one"), map2.toSortedList(), map2.toSortedList().toString());
        assertEquals(FastList.newListWith("five", "nine"), map3.toSortedList(), map3.toSortedList().toString());

        Comparator\<String> comparator = (String o1, String o2) -> o1.substring(1).compareTo(o2.substring(1));
        assertEquals(
                FastList.newListWith("zero", "nine"), map1.toSortedList(comparator), map1.toSortedList(comparator).toString());
        assertEquals(
                FastList.newListWith("nine", "one"), map2.toSortedList(comparator), map2.toSortedList(comparator).toString());
        assertEquals(FastList.newListWith("nine", "five"), map3.toSortedList(comparator), map3.toSortedList(comparator).toString());

        Function\<String, String> substring = (String object) -> object.substring(1);
        assertEquals(
                FastList.newListWith("zero", "nine"), map1.toSortedListBy(substring), map1.toSortedListBy(substring).toString());
        assertEquals(
                FastList.newListWith("nine", "one"), map2.toSortedListBy(substring), map2.toSortedListBy(substring).toString());
        assertEquals(FastList.newListWith("nine", "five"), map3.toSortedListBy(substring), map3.toSortedListBy(substring).toString());
    }

    @Test
    public void toSet()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("6")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(UnifiedSet.newSetWith("zero", "nine"), map1.toSet(), map1.toSet().toString());
        assertEquals(UnifiedSet.newSetWith("one", "nine"), map2.toSet(), map2.toSet().toString());
        assertEquals(UnifiedSet.newSetWith("five", "nine"), map3.toSet(), map3.toSet().toString());
    }

    @Test
    public void toSortedSet()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("6")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(TreeSortedSet.newSetWith("nine", "zero"), map1.toSortedSet());
        assertEquals(
                TreeSortedSet.newSetWith("nine", "one"), map2.toSortedSet(), map2.toSortedSet().toString());
        assertEquals(TreeSortedSet.newSetWith("five", "nine"), map3.toSortedSet());

        Comparator\<String> comparator = (String o1, String o2) -> o1.substring(1).compareTo(o2.substring(1));
        assertEquals(TreeSortedSet.newSetWith("zero", "nine"), map1.toSortedSet(comparator));
        assertEquals(
                TreeSortedSet.newSetWith("nine", "one"), map2.toSortedSet(comparator), map2.toSortedSet(comparator).toString());
        assertEquals(TreeSortedSet.newSetWith("nine", "five"), map3.toSortedSet(comparator));

        Function\<String, String> substring = (String object) -> object.substring(1);
        assertEquals(TreeSortedSet.newSetWith("zero", "nine"), map1.toSortedSetBy(substring));
        assertEquals(TreeSortedSet.newSetWith("nine", "one"), map2.toSortedSetBy(substring));
        assertEquals(TreeSortedSet.newSetWith("nine", "five"), map3.toSortedSetBy(substring), map3.toSortedSetBy(substring).toString());
    }

    @Test
    public void toBag()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("6")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("zero", "zero", "nine"), map1.toBag());
        assertEquals(HashBag.newBagWith("one", "one", "nine"), map2.toBag());
        assertEquals(HashBag.newBagWith("five", "five", "nine"), map3.toBag());
    }

    @Test
    public void toMap()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        Function\<String, Integer> keyFunction = StringFunctions.length();
        Function\<String, String> valueFunction = Functions.getPassThru();
        assertEquals(UnifiedMap.newWithKeysValues(1, "a", 4, "abcd"), map1.toMap(keyFunction, valueFunction));
        assertEquals(UnifiedMap.newWithKeysValues(2, "ab", 4, "abcd"), map2.toMap(keyFunction, valueFunction));
        assertEquals(UnifiedMap.newWithKeysValues(3, "abc", 4, "abcd"), map3.toMap(keyFunction, valueFunction));
    }

    @Test
    public void toMapTarget()
    {
        <name>ObjectMap\<String> map = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");

        Function\<String, String> keyStringFunction = (Function\<String, String>) each -> String.valueOf(each.length());
        Function\<String, Long> keyLongFunction = (Function\<String, Long>) each -> Long.valueOf(each.length());
        Function\<String, String> valueFunction = Functions.getPassThru();

        Map\<String, String> targetMap1 = new HashMap\<>();
        targetMap1.put("1", "a");
        targetMap1.put("4", "abcd");

        Map\<Long, String> targetMap2 = new HashMap\<>();
        targetMap2.put(1L, "a");
        targetMap2.put(4L, "abcd");

        assertEquals(targetMap1, map.toMap(keyStringFunction, valueFunction, new HashMap\<String, String>()));
        assertEquals(targetMap2, map.toMap(keyLongFunction, valueFunction, new HashMap\<Long, String>()));
        assertTrue(map.toMap(keyLongFunction, valueFunction, new HashMap\<Long, String>()) instanceof HashMap);
    }

    @Test
    public void toSortedMap()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        Function\<String, Integer> keyFunction = StringFunctions.length();
        Function\<String, String> valueFunction = Functions.getPassThru();
        assertEquals(UnifiedMap.newWithKeysValues(4, "abcd", 1, "z"), map1.toSortedMap(keyFunction, valueFunction));
        assertEquals(UnifiedMap.newWithKeysValues(2, "ab", 4, "abcd"), map2.toSortedMap(keyFunction, valueFunction));
        assertEquals(UnifiedMap.newWithKeysValues(4, "abcd", 3, "zyx"), map3.toSortedMap(keyFunction, valueFunction));
        assertEquals(UnifiedMap.newWithKeysValues(4, "abcd", 3, "zyx"), map3.toSortedMap(Comparators.naturalOrder(), keyFunction, valueFunction));
        assertEquals(UnifiedMap.newWithKeysValues(4, "abcd", 3, "zyx"), map3.toSortedMapBy(Functions.getPassThru(), keyFunction, valueFunction));
    }

    @Test
    public void toImmutableList()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        assertTrue(FastList.newListWith("zero", "nine").equals(map1.toImmutableList())
                || FastList.newListWith("nine", "zero").equals(map1.toList()), map1.toList().toString());
        assertTrue(FastList.newListWith("one", "nine").equals(map2.toImmutableList())
                || FastList.newListWith("nine", "one").equals(map2.toList()), map2.toList().toString());
        assertTrue(FastList.newListWith("five", "nine").equals(map3.toImmutableList())
                || FastList.newListWith("nine", "five").equals(map3.toList()), map3.toList().toString());
    }

    @Test
    public void toImmutableSortedList()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(
                FastList.newListWith("nine", "zero"), map1.toImmutableSortedList(), map1.toSortedList().toString());
        assertEquals(
                FastList.newListWith("nine", "one"), map2.toImmutableSortedList(), map2.toSortedList().toString());
        assertEquals(
                FastList.newListWith("five", "nine"), map3.toImmutableSortedList(), map3.toSortedList().toString());

        Comparator\<String> comparator = (String o1, String o2) -> o1.substring(1).compareTo(o2.substring(1));
        assertEquals(
                FastList.newListWith("zero", "nine"), map1.toImmutableSortedList(comparator), map1.toSortedList(comparator).toString());
        assertEquals(
                FastList.newListWith("nine", "one"), map2.toImmutableSortedList(comparator), map2.toSortedList(comparator).toString());
        assertEquals(
                FastList.newListWith("nine", "five"), map3.toImmutableSortedList(comparator), map3.toSortedList(comparator).toString());

        Function\<String, String> substring = (String object) -> object.substring(1);
        assertEquals(
                FastList.newListWith("zero", "nine"), map1.toImmutableSortedListBy(substring), map1.toSortedListBy(substring).toString());
        assertEquals(
                FastList.newListWith("nine", "one"), map2.toImmutableSortedListBy(substring), map2.toSortedListBy(substring).toString());
        assertEquals(
                FastList.newListWith("nine", "five"), map3.toImmutableSortedListBy(substring), map3.toSortedListBy(substring).toString());
    }

    @Test
    public void toImmutableSet()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("6")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(UnifiedSet.newSetWith("zero", "nine"), map1.toImmutableSet(), map1.toSet().toString());
        assertEquals(UnifiedSet.newSetWith("one", "nine"), map2.toImmutableSet(), map2.toSet().toString());
        assertEquals(UnifiedSet.newSetWith("five", "nine"), map3.toImmutableSet(), map3.toSet().toString());
    }

    @Test
    public void toImmutableSortedSet()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("6")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(TreeSortedSet.newSetWith("nine", "zero"), map1.toImmutableSortedSet());
        assertEquals(
                TreeSortedSet.newSetWith("nine", "one"), map2.toImmutableSortedSet(), map2.toImmutableSortedSet().toString());
        assertEquals(TreeSortedSet.newSetWith("five", "nine"), map3.toImmutableSortedSet());

        Comparator\<String> comparator = (String o1, String o2) -> o1.substring(1).compareTo(o2.substring(1));
        assertEquals(TreeSortedSet.newSetWith("zero", "nine"), map1.toImmutableSortedSet(comparator));
        assertEquals(
                TreeSortedSet.newSetWith("nine", "one"), map2.toImmutableSortedSet(comparator), map2.toImmutableSortedSet(comparator).toString());
        assertEquals(TreeSortedSet.newSetWith("nine", "five"), map3.toImmutableSortedSet(comparator));

        Function\<String, String> substring = (String object) -> object.substring(1);
        assertEquals(TreeSortedSet.newSetWith("zero", "nine"), map1.toImmutableSortedSetBy(substring));
        assertEquals(TreeSortedSet.newSetWith("nine", "one"), map2.toImmutableSortedSetBy(substring));
        assertEquals(TreeSortedSet.newSetWith("nine", "five"), map3.toImmutableSortedSetBy(substring), map3.toImmutableSortedSetBy(substring).toString());
    }

    @Test
    public void toImmutableBag()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("6")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("zero", "zero", "nine"), map1.toImmutableBag());
        assertEquals(HashBag.newBagWith("one", "one", "nine"), map2.toImmutableBag());
        assertEquals(HashBag.newBagWith("five", "five", "nine"), map3.toImmutableBag());
    }

    @Test
    public void toImmutableSortedBag()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");

        Verify.assertSortedBagsEqual(TreeBag.newBagWith("zero", "zero", "nine"), map1.toImmutableSortedBag());
        Verify.assertSortedBagsEqual(TreeBag.newBagWith(Comparator.reverseOrder(), "one", "one", "nine"), map2.toImmutableSortedBag(Comparator.\<String>reverseOrder()));
    }

    @Test
    public void toImmutableSortedBagBy()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");

        Verify.assertSortedBagsEqual(TreeBag.newBagWith(Comparators.byFunction(String::valueOf), "zero", "zero", "nine"), map1.toImmutableSortedBagBy(String::valueOf));
    }

    @Test
    public void toArray()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        assertTrue(Arrays.equals(new String[]{"abcd", "z"}, map1.toArray())
                || Arrays.equals(new String[]{"z", "abcd"}, map1.toArray()), map1.asLazy().toString());
        assertTrue(Arrays.equals(new String[]{"abcd", "ab"}, map2.toArray())
                || Arrays.equals(new String[]{"ab", "abcd"}, map2.toArray()), map2.asLazy().toString());
        assertTrue(Arrays.equals(new String[]{"abcd", "zyx"}, map3.toArray())
                || Arrays.equals(new String[]{"zyx", "abcd"}, map3.toArray()), map3.asLazy().toString());

        assertTrue(Arrays.equals(new String[]{"abcd", "z"}, map1.toArray(new String[2]))
                || Arrays.equals(new String[]{"z", "abcd"}, map1.toArray()), map1.asLazy().toString());
        assertTrue(Arrays.equals(new String[]{"abcd", "ab"}, map2.toArray(new String[4]))
                || Arrays.equals(new String[]{"ab", "abcd"}, map2.toArray()), map2.asLazy().toString());
        assertTrue(Arrays.equals(new String[]{"abcd", "zyx"}, map3.toArray(new String[2]))
                || Arrays.equals(new String[]{"zyx", "abcd"}, map3.toArray()), map3.asLazy().toString());
    }

    @Test
    public void min()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        assertEquals("abcd", map1.min());
        assertEquals("ab", map2.min());
        assertEquals("abcd", map3.min());
        assertEquals("abcd", map3.min(Comparators.naturalOrder()));
    }

    @Test
    public void min_throws_empty()
    {
        assertThrows(NoSuchElementException.class, () -> <name>ObjectHashMap.newMap().min());
    }

    @Test
    public void maxBy()
    {
        <name>ObjectMap\<Class\<?>\> map1 = this.newWithKeysValues(<(literal.(type))("0")>, <name>ObjectHashMapTest.class, <(literal.(type))("9")>, <name>ObjectHashMap.class);
        <name>ObjectMap\<Class\<?>\> map2 = this.newWithKeysValues(<(literal.(type))("1")>, <name>ObjectHashMapTest.class, <(literal.(type))("9")>, <name>ObjectHashMap.class);
        <name>ObjectMap\<Class\<?>\> map3 = this.newWithKeysValues(<(literal.(type))("5")>, <name>ObjectHashMap.class, <(literal.(type))("9")>, <name>ObjectHashMapTest.class);

        Function\<Class\<?>, Integer> classNameLength = (Class\<?> aClass) -> aClass.getName().length();
        assertEquals(<name>ObjectHashMapTest.class, map1.maxBy(classNameLength));
        assertEquals(<name>ObjectHashMapTest.class, map2.maxBy(classNameLength));
        assertEquals(<name>ObjectHashMapTest.class, map3.maxBy(classNameLength));

        assertThrows(NoSuchElementException.class, () -> <name>ObjectHashMap.\<Class\<?>\>newMap().maxBy(classNameLength));
    }

    @Test
    public void max()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        assertEquals("z", map1.max());
        assertEquals("abcd", map2.max());
        assertEquals("zyx", map3.max());
        assertEquals("zyx", map3.max(Comparators.naturalOrder()));
    }

    @Test
    public void max_throws_empty()
    {
        assertThrows(NoSuchElementException.class, () -> <name>ObjectHashMap.newMap().max());
    }

    @Test
    public void minBy()
    {
        <name>ObjectMap\<Class\<?>\> map1 = this.newWithKeysValues(<(literal.(type))("0")>, <name>ObjectHashMapTest.class, <(literal.(type))("9")>, <name>ObjectHashMap.class);
        <name>ObjectMap\<Class\<?>\> map2 = this.newWithKeysValues(<(literal.(type))("1")>, <name>ObjectHashMapTest.class, <(literal.(type))("9")>, <name>ObjectHashMap.class);
        <name>ObjectMap\<Class\<?>\> map3 = this.newWithKeysValues(<(literal.(type))("5")>, <name>ObjectHashMap.class, <(literal.(type))("9")>, <name>ObjectHashMapTest.class);

        Function\<Class\<?>, Integer> classNameLength = (Class\<?> object) -> object.getName().length();
        assertEquals(<name>ObjectHashMap.class, map1.minBy(classNameLength));
        assertEquals(<name>ObjectHashMap.class, map2.minBy(classNameLength));
        assertEquals(<name>ObjectHashMap.class, map3.minBy(classNameLength));

        assertThrows(NoSuchElementException.class, () -> <name>ObjectHashMap.\<Class\<?>\>newMap().minBy(classNameLength));
    }

    @Test
    public void sumOfInt()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        IntFunction\<String> function = StringFunctions.length();
        assertEquals(5L, map1.sumOfInt(function));
        assertEquals(6L, map2.sumOfInt(function));
        assertEquals(7L, map3.sumOfInt(function));
    }

    @Test
    public void sumOfLong()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        LongFunction\<String> function = String::length;
        assertEquals(5L, map1.sumOfLong(function));
        assertEquals(6L, map2.sumOfLong(function));
        assertEquals(7L, map3.sumOfLong(function));
    }

    @Test
    public void sumOfDouble()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        DoubleFunction\<String> function = String::length;
        assertEquals(5.0, map1.sumOfDouble(function), 0.0);
        assertEquals(6.0, map2.sumOfDouble(function), 0.0);
        assertEquals(7.0, map3.sumOfDouble(function), 0.0);
    }

    @Test
    public void sumOfFloat()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        FloatFunction\<String> function = String::length;
        assertEquals(5.0, map1.sumOfFloat(function), 0.0);
        assertEquals(6.0, map2.sumOfFloat(function), 0.0);
        assertEquals(7.0, map3.sumOfFloat(function), 0.0);
    }

    @Test
    public void sumByInt()
    {
        RichIterable\<String> values = this.newWithKeysValues(<(literal.(type))("1")>, "1", <(literal.(type))("2")>, "2", <(literal.(type))("3")>, "3");
        ObjectLongMap\<Integer> result = values.sumByInt(s -> Integer.parseInt(s) % 2, Integer::parseInt);
        assertEquals(4, result.get(1));
        assertEquals(2, result.get(0));
    }

    @Test
    public void sumByFloat()
    {
        RichIterable\<String> values = this.newWithKeysValues(<(literal.(type))("1")>, "1", <(literal.(type))("2")>, "2", <(literal.(type))("3")>, "3");
        ObjectDoubleMap\<Integer> result = values.sumByFloat(s -> Integer.parseInt(s) % 2, Float::parseFloat);
        assertEquals(4.0f, result.get(1), 0.0);
        assertEquals(2.0f, result.get(0), 0.0);
    }

    @Test
    public void sumByLong()
    {
        RichIterable\<String> values = this.newWithKeysValues(<(literal.(type))("1")>, "1", <(literal.(type))("2")>, "2", <(literal.(type))("3")>, "3");
        ObjectLongMap\<Integer> result = values.sumByLong(s -> Integer.parseInt(s) % 2, Long::parseLong);
        assertEquals(4, result.get(1));
        assertEquals(2, result.get(0));
    }

    @Test
    public void sumByDouble()
    {
        RichIterable\<String> values = this.newWithKeysValues(<(literal.(type))("1")>, "1", <(literal.(type))("2")>, "2", <(literal.(type))("3")>, "3");
        ObjectDoubleMap\<Integer> result = values.sumByDouble(s -> Integer.parseInt(s) % 2, Double::parseDouble);
        assertEquals(4.0d, result.get(1), 0.0);
        assertEquals(2.0d, result.get(0), 0.0);
    }

    @Test
    public void keysView()
    {
        assertEquals(<name>ArrayList.newListWith(), this.getEmptyMap().keysView().toList());
        assertEquals(<name>ArrayList.newListWith(<(literal.(type))("1")>), this.newWithKeysValues(<(literal.(type))("1")>, "one").keysView().toList());
    }

    @Test
    public void reject()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine"),
                map1.reject((<type> value, String object) -> (value % 2) == 0));

        <name>ObjectPredicate\<String> keyLessThanSeven = (<type> value, String object) -> value > 7;

        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one"), map1.reject(keyLessThanSeven));
        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero"), map2.reject(keyLessThanSeven));
        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one"), map3.reject(keyLessThanSeven));
        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("5")>, "five"), map4.reject(keyLessThanSeven));

        assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine"),
                map1.reject((<type> value, String object) -> !object.endsWith("ne")));

        RichIterable\<String> actual1 = map1.reject(StringPredicates.endsWith("ne").not());
        assertTrue(HashBag.newBagWith("one", "nine").equals(actual1));
        assertEquals(HashBag.newBagWith("nine"), map1.reject(Predicates.equal("nine").not()));
        assertEquals(HashBag.newBagWith("zero"), map1.reject(StringPredicates.endsWith("o").not()));
        assertEquals(HashBag.newBagWith("nine"), map1.reject(Predicates.equal("nine").not(), HashBag.\<String>newBag()));
        assertEquals(HashBag.newBagWith("one", "nine"), map1.reject(StringPredicates.endsWith("ne").not(), HashBag.\<String>newBag()));
        assertEquals(HashBag.newBagWith("zero"), map1.reject(StringPredicates.endsWith("o").not(), HashBag.\<String>newBag()));
    }

    @Test
    public void rejectWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("one", "nine"), map1.rejectWith(StringPredicates2.notEndsWith(), "ne"));
        assertEquals(HashBag.newBagWith("nine"), map1.rejectWith(Predicates2.notEqual(), "nine"));
        assertEquals(HashBag.newBagWith("zero"), map1.rejectWith(StringPredicates2.notEndsWith(), "o"));
    }

    @Test
    public void rejectWith_withTarget()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        assertEquals(HashBag.newBagWith("one", "nine"), map1.rejectWith(StringPredicates2.notEndsWith(), "ne", HashBag.\<String>newBag()));
        assertEquals(HashBag.newBagWith("nine"), map1.rejectWith(Predicates2.notEqual(), "nine", HashBag.\<String>newBag()));
        assertEquals(HashBag.newBagWith("zero"), map1.rejectWith(StringPredicates2.notEndsWith(), "o", HashBag.\<String>newBag()));
    }

    @Test
    public void partition()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate\<String> endsWithNe = StringPredicates.endsWith("ne");
        PartitionIterable\<String> partition = map1.partition(endsWithNe);
        assertTrue(HashBag.newBagWith("one", "nine").equals(partition.getSelected()));
        assertEquals(HashBag.newBagWith("zero"), partition.getRejected());
    }

    @Test
    public void partitionWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate2\<String, String> endsWith = StringPredicates2.endsWith();
        PartitionIterable\<String> partition = map1.partitionWith(endsWith, "ne");
        assertTrue(HashBag.newBagWith("one", "nine").equals(partition.getSelected()));
        assertEquals(HashBag.newBagWith("zero"), partition.getRejected());
    }

    @Test
    public void get()
    {
        assertEquals("zero", this.classUnderTest().get(<(literal.(type))("0")>));
        assertEquals("thirtyOne", this.classUnderTest().get(<(literal.(type))("31")>));
        assertEquals("thirtyTwo", this.classUnderTest().get(<(literal.(type))("32")>));

        assertNull(this.classUnderTest().get(<(literal.(type))("1")>));
        assertNull(this.classUnderTest().get(<(literal.(type))("33")>));

        <name>ObjectMap\<Object> emptyMap = this.getEmptyMap();
        assertNull(emptyMap.get(<(literal.(type))("0")>));
        assertNull(emptyMap.get(<(literal.(type))("1")>));
        assertNull(emptyMap.get(<(literal.(type))("33")>));
    }

    @Test
    public void getIfAbsent()
    {
        Function0\<String> ifAbsent = () -> "ifAbsent";

        assertEquals("zero", this.classUnderTest().getIfAbsent(<(literal.(type))("0")>, ifAbsent));
        assertEquals("thirtyOne", this.classUnderTest().getIfAbsent(<(literal.(type))("31")>, ifAbsent));
        assertEquals("thirtyTwo", this.classUnderTest().getIfAbsent(<(literal.(type))("32")>, ifAbsent));

        assertEquals("ifAbsent", this.classUnderTest().getIfAbsent(<(literal.(type))("1")>, ifAbsent));
        assertEquals("ifAbsent", this.classUnderTest().getIfAbsent(<(literal.(type))("33")>, ifAbsent));

        <name>ObjectMap\<Object> emptyMap = this.getEmptyMap();
        assertEquals("ifAbsent", emptyMap.getIfAbsent(<(literal.(type))("0")>, ifAbsent));
        assertEquals("ifAbsent", emptyMap.getIfAbsent(<(literal.(type))("1")>, ifAbsent));
        assertEquals("ifAbsent", emptyMap.getIfAbsent(<(literal.(type))("33")>, ifAbsent));
    }

    @Test
    public void containsKey()
    {
        assertTrue(this.classUnderTest().containsKey(<(literal.(type))("0")>));
        assertTrue(this.classUnderTest().containsKey(<(literal.(type))("31")>));
        assertTrue(this.classUnderTest().containsKey(<(literal.(type))("32")>));
        assertFalse(this.classUnderTest().containsKey(<(literal.(type))("1")>));
        assertFalse(this.classUnderTest().containsKey(<(literal.(type))("5")>));
        assertFalse(this.classUnderTest().containsKey(<(literal.(type))("35")>));
    }

    @Test
    public void containsValue()
    {
        assertFalse(this.classUnderTest().containsValue(null));
        assertTrue(this.classUnderTest().containsValue("zero"));
        assertTrue(this.classUnderTest().containsValue("thirtyOne"));
        assertTrue(this.classUnderTest().containsValue("thirtyTwo"));
    }

    @Test
    public void forEachValue()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        String[] concat = {"", "", "", ""};

        map1.forEachValue((String each) -> concat[0] += each);
        map2.forEachValue((String each) -> concat[1] += each);
        map3.forEachValue((String each) -> concat[2] += each);
        map4.forEachValue((String each) -> concat[3] += each);

        assertTrue("onefive".equals(concat[0]) || "fiveone".equals(concat[0]), concat[0]);
        assertTrue("onezero".equals(concat[1]) || "zeroone".equals(concat[1]), concat[1]);
        assertTrue("twofive".equals(concat[2]) || "fivetwo".equals(concat[2]), concat[2]);
        assertTrue("zerofive".equals(concat[3]) || "fivezero".equals(concat[3]), concat[3]);
    }

    @Test
    public void forEachKey()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        <wideType.(type)>[] sum = new <wideType.(type)>[4];

        map1.forEachKey((<type> each) -> sum[0] += each);
        map2.forEachKey((<type> each) -> sum[1] += each);
        map3.forEachKey((<type> each) -> sum[2] += each);
        map4.forEachKey((<type> each) -> sum[3] += each);

        assertEquals(<(wideLiteral.(type))("6")>, sum[0]<(wideDelta.(type))>);
        assertEquals(<(wideLiteral.(type))("1")>, sum[1]<(wideDelta.(type))>);
        assertEquals(<(wideLiteral.(type))("7")>, sum[2]<(wideDelta.(type))>);
        assertEquals(<(wideLiteral.(type))("5")>, sum[3]<(wideDelta.(type))>);
    }

    @Test
    public void forEachKeyValue()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        String[] concat = {"", "", "", ""};

        map1.forEachKeyValue((<type> each, String parameter) ->
        {
            concat[0] += each;
            concat[0] += parameter;
        });
        map2.forEachKeyValue((<type> each, String parameter) ->
        {
            concat[1] += each;
            concat[1] += parameter;
        });
        map3.forEachKeyValue((<type> each, String parameter) ->
        {
            concat[2] += each;
            concat[2] += parameter;
        });
        map4.forEachKeyValue((<type> each, String parameter) ->
        {
            concat[3] += each;
            concat[3] += parameter;
        });

        assertTrue("<(toStringLiteral.(type))("1")>one<(toStringLiteral.(type))("5")>five".equals(concat[0]) || "<(toStringLiteral.(type))("5")>five<(toStringLiteral.(type))("1")>one".equals(concat[0]), concat[0]);
        assertTrue("<(toStringLiteral.(type))("1")>one<(toStringLiteral.(type))("0")>zero".equals(concat[1]) || "<(toStringLiteral.(type))("0")>zero<(toStringLiteral.(type))("1")>one".equals(concat[1]), concat[1]);
        assertTrue("<(toStringLiteral.(type))("2")>two<(toStringLiteral.(type))("5")>five".equals(concat[2]) || "<(toStringLiteral.(type))("5")>five<(toStringLiteral.(type))("2")>two".equals(concat[2]), concat[2]);
        assertTrue("<(toStringLiteral.(type))("0")>zero<(toStringLiteral.(type))("5")>five".equals(concat[3]) || "<(toStringLiteral.(type))("5")>five<(toStringLiteral.(type))("0")>zero".equals(concat[3]), concat[3]);
    }

    @Test
    public void injectIntoKeyValue()
    {
        <name>ObjectMap\<String> map0 = this.newWithKeysValues(<(literal.(type))("2")>, "3", <(literal.(type))("4")>, "5");

        String result0 = map0.injectIntoKeyValue(new String("1"), (result, eachKey, eachValue) -> result + String.valueOf(eachKey) + eachValue);
        assertTrue("1<(toStringLiteral.(type))("2")>3<(toStringLiteral.(type))("4")>5".equals(result0) || "1<(toStringLiteral.(type))("4")>5<(toStringLiteral.(type))("2")>3".equals(result0), result0);

        <name>ObjectMap copy = map0.injectIntoKeyValue(<name>ObjectMaps.mutable.empty(), Mutable<name>ObjectMap::withKeyValue);
        assertEquals(map0, copy);
    }

    @Test
    public void size()
    {
        assertEquals(0, this.getEmptyMap().size());
        assertEquals(2, this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five").size());
        assertEquals(2, this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five").size());
        assertEquals(3, this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five").size());
        assertEquals(2, this.newWithKeysValues(<(literal.(type))("6")>, "six", <(literal.(type))("5")>, "five").size());
    }

    @Test
    public void isEmpty()
    {
        assertTrue(this.getEmptyMap().isEmpty());
        assertFalse(this.classUnderTest().isEmpty());
        assertFalse(this.newWithKeysValues(<(literal.(type))("1")>, "one").isEmpty());
        assertFalse(this.newWithKeysValues(<(literal.(type))("0")>, "zero").isEmpty());
        assertFalse(this.newWithKeysValues(<(literal.(type))("50")>, "fifty").isEmpty());
    }

    @Test
    public void notEmpty()
    {
        assertFalse(this.getEmptyMap().notEmpty());
        assertTrue(this.classUnderTest().notEmpty());
        assertTrue(this.newWithKeysValues(<(literal.(type))("1")>, "one").notEmpty());
        assertTrue(this.newWithKeysValues(<(literal.(type))("0")>, "zero").notEmpty());
        assertTrue(this.newWithKeysValues(<(literal.(type))("50")>, "fifty").notEmpty());
    }

    @Test
    public void getFirst()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");

        assertTrue("one".equals(map1.getFirst()) || "five".equals(map1.getFirst()), map1.getFirst());
        assertTrue("one".equals(map2.getFirst()) || "zero".equals(map2.getFirst()), map2.getFirst());
        assertTrue("two".equals(map3.getFirst()) || "five".equals(map3.getFirst()), map3.getFirst());
        assertTrue("zero".equals(map4.getFirst()) || "five".equals(map4.getFirst()), map4.getFirst());
        assertNull(<name>ObjectHashMap.newMap().getFirst());
    }

    @Test
    public void getLast()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");

        assertTrue("one".equals(map1.getLast()) || "five".equals(map1.getLast()), map1.getLast());
        assertTrue("one".equals(map2.getLast()) || "zero".equals(map2.getLast()), map2.getLast());
        assertTrue("two".equals(map3.getLast()) || "five".equals(map3.getLast()), map3.getLast());
        assertTrue("zero".equals(map4.getLast()) || "five".equals(map4.getLast()), map4.getLast());
        assertEquals("zero", this.newWithKeysValues(<(literal.(type))("0")>, "zero").getLast());
        assertNull(<name>ObjectHashMap.newMap().getLast());
    }

    @Test
    public void getOnly()
    {
        assertEquals("zero", this.newWithKeysValues(<(literal.(type))("0")>, "zero").getOnly());
        assertEquals("one", this.newWithKeysValues(<(literal.(type))("1")>, "one").getOnly());
        assertEquals("two", this.newWithKeysValues(<(literal.(type))("2")>, "two").getOnly());
    }

    @Test
    public void getOnly_empty_throws()
    {
        assertThrows(IllegalStateException.class, () -> this.getEmptyMap().getOnly());
    }

    @Test
    public void getOnly_not_only_one_throws()
    {
        assertThrows(IllegalStateException.class, () ->
                this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five").getOnly());
    }

    @Test
    public void contains()
    {
        assertFalse(this.classUnderTest().contains(null));
        assertTrue(this.classUnderTest().contains("zero"));
        assertTrue(this.classUnderTest().contains("thirtyOne"));
        assertTrue(this.classUnderTest().contains("thirtyTwo"));
    }

    @Test
    public void containsAllIterable()
    {
        assertTrue(this.classUnderTest().containsAllIterable(FastList.newListWith("zero", "thirtyOne")));
        assertTrue(this.classUnderTest().containsAllIterable(FastList.newListWith("zero", "thirtyOne", "thirtyTwo")));
        assertFalse(this.classUnderTest().containsAllIterable(FastList.newListWith("zero", "one", "thirtyTwo")));
        assertFalse(this.classUnderTest().containsAllIterable(FastList.newListWith("two", "one", "nine")));
    }

    @Test
    public void containsAll()
    {
        assertTrue(this.classUnderTest().containsAll(FastList.newListWith("zero", "thirtyOne")));
        assertTrue(this.classUnderTest().containsAll(FastList.newListWith("zero", "thirtyOne", "thirtyTwo")));
        assertFalse(this.classUnderTest().containsAll(FastList.newListWith("zero", "one", "thirtyTwo")));
        assertFalse(this.classUnderTest().containsAll(FastList.newListWith("two", "one", "nine")));
    }

    @Test
    public void containsAnyIterable()
    {
        assertTrue(this.classUnderTest().containsAnyIterable(FastList.newListWith("zero", "thirtyOne")));
        assertTrue(this.classUnderTest().containsAnyIterable(FastList.newListWith("zero", "thirtyOne", "thirtyTwo")));
        assertFalse(this.classUnderTest().containsAnyIterable(FastList.newListWith("none")));
    }

    @Test
    public void containsAny()
    {
        assertTrue(this.classUnderTest().containsAny(FastList.newListWith("zero", "thirtyOne")));
        assertTrue(this.classUnderTest().containsAny(FastList.newListWith("zero", "thirtyOne", "thirtyTwo")));
        assertFalse(this.classUnderTest().containsAny(FastList.newListWith("none")));
    }

    @Test
    public void containsNoneIterable()
    {
        assertFalse(this.classUnderTest().containsNoneIterable(FastList.newListWith("zero", "thirtyOne")));
        assertFalse(this.classUnderTest().containsNoneIterable(FastList.newListWith("zero", "thirtyOne", "thirtyTwo")));
        assertTrue(this.classUnderTest().containsNoneIterable(FastList.newListWith("none")));
    }

    @Test
    public void containsNone()
    {
        assertFalse(this.classUnderTest().containsNone(FastList.newListWith("zero", "thirtyOne")));
        assertFalse(this.classUnderTest().containsNone(FastList.newListWith("zero", "thirtyOne", "thirtyTwo")));
        assertTrue(this.classUnderTest().containsNone(FastList.newListWith("none")));
    }

    @Test
    public void containsAllArguments()
    {
        assertTrue(this.classUnderTest().containsAllArguments("zero", "thirtyOne"));
        assertTrue(this.classUnderTest().containsAllArguments("zero", "thirtyOne", "thirtyTwo"));
        assertFalse(this.classUnderTest().containsAllArguments("zero", "one", "thirtyTwo"));
        assertFalse(this.classUnderTest().containsAllArguments("two", "one", "nine"));
    }

    @Test
    public void testEquals()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo", <(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "two", <(literal.(type))("32")>, "thirtyTwo");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "one", <(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        <name>ObjectMap\<String> map5 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyThree");
        <name>ObjectMap\<String> map6 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        <name>ObjectMap\<String> map7 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("32")>, "thirtyTwo");
        <name>ObjectMap\<String> map8 = this.newWithKeysValues(<(literal.(type))("50")>, "zero", <(literal.(type))("60")>, "one", <(literal.(type))("70")>, "thirtyThree");
        <name>ObjectMap\<String> map9 = this.newWithKeysValues(<(literal.(type))("50")>, "zero", <(literal.(type))("60")>, "one");
        <name>ObjectMap\<String> map10 = this.newWithKeysValues(<(literal.(type))("50")>, "zero");

        Verify.assertEqualsAndHashCode(map1, map2);
        Verify.assertPostSerializedEqualsAndHashCode(map1);
        Verify.assertPostSerializedEqualsAndHashCode(map6);
        Verify.assertPostSerializedEqualsAndHashCode(map7);
        Verify.assertPostSerializedEqualsAndHashCode(map8);
        Verify.assertPostSerializedEqualsAndHashCode(map10);
        Verify.assertPostSerializedEqualsAndHashCode(<name>ObjectHashMap.newMap());
        Verify.assertEqualsAndHashCode(map1, map2);
        assertNotEquals(map1, map3);
        assertNotEquals(map1, map4);
        assertNotEquals(map1, map5);
        assertNotEquals(map1, map6);
        assertNotEquals(map1, map7);
        assertNotEquals(map8, map5);
        assertNotEquals(map9, map8);
        assertNotEquals(this.newWithKeysValues(<(literal.(type))("0")>, null), this.newWithKeysValues(<(literal.(type))("6")>, ""));
        assertNotEquals(this.newWithKeysValues(<(literal.(type))("5")>, null), this.newWithKeysValues(<(literal.(type))("6")>, ""));

        assertEquals(map1, <name>ObjectMaps.mutable.ofAll(map1));
        assertEquals(map1, <name>ObjectMaps.immutable.ofAll(map1));
    }

    @Test
    public void testHashCode()
    {
        assertEquals(UnifiedMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo").hashCode(), this.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo", <(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one").hashCode());
        assertEquals(UnifiedMap.newWithKeysValues(<(literal.(type))("0")>, null, <(literal.(type))("1")>, null).hashCode(), this.newWithKeysValues(<(literal.(type))("0")>, null, <(literal.(type))("1")>, null).hashCode());
        assertEquals(UnifiedMap.newWithKeysValues(<(literal.(type))("50")>, "zero", <(literal.(type))("60")>, "one", <(literal.(type))("70")>, "thirtyThree").hashCode(), this.newWithKeysValues(<(literal.(type))("50")>, "zero", <(literal.(type))("60")>, "one", <(literal.(type))("70")>, "thirtyThree").hashCode());
        assertEquals(UnifiedMap.newWithKeysValues(<(literal.(type))("50")>, null, <(literal.(type))("60")>, null).hashCode(), this.newWithKeysValues(<(literal.(type))("50")>, null, <(literal.(type))("60")>, null).hashCode());
        assertEquals(UnifiedMap.newMap().hashCode(), this.getEmptyMap().hashCode());
    }

    @Test
    public void testToString()
    {
        assertEquals("{}", this.getEmptyMap().toString());
        assertEquals("{<(toStringLiteral.(type))("0")>=zero}", this.newWithKeysValues(<(literal.(type))("0")>, "zero").toString());
        assertEquals("{<(toStringLiteral.(type))("1")>=one}", this.newWithKeysValues(<(literal.(type))("1")>, "one").toString());
        assertEquals("{<(toStringLiteral.(type))("5")>=five}", this.newWithKeysValues(<(literal.(type))("5")>, "five").toString());

        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        assertTrue(
                "{<(toStringLiteral.(type))("0")>=zero, <(toStringLiteral.(type))("1")>=one}".equals(map1.toString())
                        || "{<(toStringLiteral.(type))("1")>=one, <(toStringLiteral.(type))("0")>=zero}".equals(map1.toString()), map1.toString());

        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        assertTrue(
                "{<(toStringLiteral.(type))("1")>=one, <(toStringLiteral.(type))("32")>=thirtyTwo}".equals(map2.toString())
                        || "{<(toStringLiteral.(type))("32")>=thirtyTwo, <(toStringLiteral.(type))("1")>=one}".equals(map2.toString()), map2.toString());

        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("32")>, "thirtyTwo");
        assertTrue(
                "{<(toStringLiteral.(type))("0")>=zero, <(toStringLiteral.(type))("32")>=thirtyTwo}".equals(map3.toString())
                        || "{<(toStringLiteral.(type))("32")>=thirtyTwo, <(toStringLiteral.(type))("0")>=zero}".equals(map3.toString()), map3.toString());

        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo", <(literal.(type))("33")>, "thirtyThree");
        assertTrue(
                "{<(toStringLiteral.(type))("32")>=thirtyTwo, <(toStringLiteral.(type))("33")>=thirtyThree}".equals(map4.toString())
                        || "{<(toStringLiteral.(type))("33")>=thirtyThree, <(toStringLiteral.(type))("32")>=thirtyTwo}".equals(map4.toString()), map4.toString());
    }

    @Test
    public void zip()
    {
        RichIterable\<Pair\<String, Integer>\> zip1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .zip(FastList.newListWith(0, 5, 6));
        RichIterable\<Pair\<String, Integer>\> zip2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .zip(FastList.newListWith(1));
        RichIterable\<Pair\<String, Integer>\> zip3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .zip(FastList.newListWith(1), FastList.\<Pair\<String, Integer>\>newList());
        assertTrue(HashBag.newBagWith(Tuples.pair("zero", 0), Tuples.pair("five", 5)).equals(zip1)
                || HashBag.newBagWith(Tuples.pair("five", 0), Tuples.pair("zero", 5)).equals(zip1));
        assertTrue(HashBag.newBagWith(Tuples.pair("one", 1)).equals(zip2)
                || HashBag.newBagWith(Tuples.pair("five", 1)).equals(zip2));
        assertTrue(FastList.newListWith(Tuples.pair("one", 1)).equals(zip3)
                || FastList.newListWith(Tuples.pair("five", 1)).equals(zip3));
    }

    @Test
    public void zipWithIndex()
    {
        RichIterable\<Pair\<String, Integer>\> zip1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .zipWithIndex();
        RichIterable\<Pair\<String, Integer>\> zip2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .zipWithIndex();
        RichIterable\<Pair\<String, Integer>\> zip3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .zipWithIndex(FastList.\<Pair\<String, Integer>\>newList());
        assertTrue(UnifiedSet.newSetWith(Tuples.pair("zero", 0), Tuples.pair("five", 1)).equals(zip1)
                || UnifiedSet.newSetWith(Tuples.pair("five", 0), Tuples.pair("zero", 1)).equals(zip1));
        assertTrue(UnifiedSet.newSetWith(Tuples.pair("one", 0), Tuples.pair("five", 1)).equals(zip2)
                || UnifiedSet.newSetWith(Tuples.pair("five", 0), Tuples.pair("one", 1)).equals(zip2));
        assertTrue(FastList.newListWith(Tuples.pair("one", 0), Tuples.pair("five", 1)).equals(zip3)
                || FastList.newListWith(Tuples.pair("five", 0), Tuples.pair("one", 1)).equals(zip3));
    }

    @Test
    public void chunk()
    {
        RichIterable\<RichIterable\<String>\> chunk1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .chunk(1);
        RichIterable\<RichIterable\<String>\> chunk2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .chunk(1);
        assertTrue(FastList.newListWith(FastList.newListWith("zero"), FastList.newListWith("five")).equals(chunk1)
                || FastList.newListWith(FastList.newListWith("five"), FastList.newListWith("zero")).equals(chunk1));
        assertTrue(FastList.newListWith(FastList.newListWith("one"), FastList.newListWith("five")).equals(chunk2)
                || FastList.newListWith(FastList.newListWith("five"), FastList.newListWith("one")).equals(chunk2));
    }

    @Test
    public void chunk_throws_negative_size()
    {
        assertThrows(IllegalArgumentException.class, () -> this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .chunk(-1));
    }

    @Test
    public void chunk_throws_zero_size()
    {
        assertThrows(IllegalArgumentException.class, () -> this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .chunk(0));
    }

    @Test
    public void aggregateInPlaceBy()
    {
        Function0\<AtomicInteger> valueCreator = Functions0.zeroAtomicInteger();
        Procedure2\<AtomicInteger, Integer> sumAggregator = AtomicInteger::addAndGet;
        <name>ObjectMap\<Integer> collection = this.newWithKeysValues(<(literal.(type))("1")>, 1, <(literal.(type))("2")>, 2, <(literal.(type))("3")>, 3);
        MapIterable\<String, AtomicInteger> aggregation = collection.aggregateInPlaceBy(String::valueOf, valueCreator, sumAggregator);
        assertEquals(1, aggregation.get("1").intValue());
        assertEquals(2, aggregation.get("2").intValue());
        assertEquals(3, aggregation.get("3").intValue());
    }

    @Test
    public void aggregateBy()
    {
        Function0\<Integer> valueCreator = Functions0.value(0);
        Function2\<Integer, Integer, Integer> sumAggregator = (Integer aggregate, Integer value) -> aggregate + value;
        <name>ObjectMap\<Integer> collection = this.newWithKeysValues(<(literal.(type))("1")>, 1, <(literal.(type))("2")>, 2, <(literal.(type))("3")>, 3);
        MapIterable\<String, Integer> aggregation = collection.aggregateBy(String::valueOf, valueCreator, sumAggregator);
        assertEquals(1, aggregation.get("1").intValue());
        assertEquals(2, aggregation.get("2").intValue());
        assertEquals(3, aggregation.get("3").intValue());
    }

    @Test
    public void groupBy()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("3")>, "three");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("4")>, "four");

        FastListMultimap\<Character, String> expected1 = FastListMultimap.newMultimap(Tuples.pair('z', "zero"), Tuples.pair('o', "one"));
        FastListMultimap\<Character, String> expected2 = FastListMultimap.newMultimap(Tuples.pair('t', "two"), Tuples.pair('t', "three"));
        FastListMultimap\<Character, String> expected4 = FastListMultimap.newMultimap(Tuples.pair('f', "four"));

        Function\<String, Character> firstChar = (String object) -> object.charAt(0);

        Multimap\<Character, String> actual1 = map1.groupBy(firstChar);
        Multimap\<Character, String> actual2 = map2.groupBy(firstChar);
        Multimap\<Character, String> actual3 = map2.groupBy(firstChar, FastListMultimap.\<Character, String>newMultimap());
        Multimap\<Character, String> actual4 = map3.groupBy(firstChar);
        Multimap\<Character, String> actual5 = map3.groupBy(firstChar, FastListMultimap.\<Character, String>newMultimap());

        Verify.assertSize(expected1.size(), actual1);
        expected1.forEachKeyValue((Character argument1, String argument2) -> assertTrue(actual1.containsKeyAndValue(argument1, argument2)));

        Verify.assertSize(expected2.size(), actual2);
        expected2.forEachKeyValue((Character argument1, String argument2) -> assertTrue(actual2.containsKeyAndValue(argument1, argument2)));

        Verify.assertSize(expected2.size(), actual3);
        expected2.forEachKeyValue((Character argument1, String argument2) -> assertTrue(actual3.containsKeyAndValue(argument1, argument2)));

        Verify.assertSize(expected4.size(), actual4);
        expected4.forEachKeyValue((Character argument1, String argument2) -> assertTrue(actual4.containsKeyAndValue(argument1, argument2)));

        Verify.assertSize(expected4.size(), actual5);
        expected4.forEachKeyValue((Character argument1, String argument2) -> assertTrue(actual5.containsKeyAndValue(argument1, argument2)));
    }

    @Test
    public void groupByEach()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one");

        Function\<String, UnifiedSet\<Character>\> toChars = (String object) ->
        {
            UnifiedSet\<Character> list = UnifiedSet.newSet();
            char[] chars = object.toCharArray();
            for (char aChar : chars)
            {
                list.add(aChar);
            }
            return list;
        };

        FastListMultimap\<Character, String> expected = FastListMultimap.newMultimap(Tuples.pair('z', "zero"), Tuples.pair('e', "zero"), Tuples.pair('r', "zero"), Tuples.pair('o', "zero"), Tuples.pair('n', "nine"), Tuples.pair('i', "nine"), Tuples.pair('e', "nine"));
        FastListMultimap\<Character, String> expected2 = FastListMultimap.newMultimap(Tuples.pair('o', "one"), Tuples.pair('n', "one"), Tuples.pair('e', "one"));

        Multimap\<Character, String> actual = map1.groupByEach(toChars);
        Multimap\<Character, String> actual1 = map1.groupByEach(toChars, FastListMultimap.\<Character, String>newMultimap());
        Multimap\<Character, String> actual2 = map2.groupByEach(toChars);
        Multimap\<Character, String> actual3 = map2.groupByEach(toChars, FastListMultimap.\<Character, String>newMultimap());

        expected.forEachKeyValue((Character argument1, String argument2) -> assertTrue(actual.containsKeyAndValue(argument1, argument2)));

        expected.forEachKeyValue((Character argument1, String argument2) -> assertTrue(actual1.containsKeyAndValue(argument1, argument2)));

        expected2.forEachKeyValue((Character argument1, String argument2) -> assertTrue(actual2.containsKeyAndValue(argument1, argument2)));

        expected2.forEachKeyValue((Character argument1, String argument2) -> assertTrue(actual3.containsKeyAndValue(argument1, argument2)));
    }

    @Test
    public void groupByUniqueKey()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("2")>, "two");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("2")>, "two");

        Function\<String, Character> firstChar = (String object) -> object.charAt(0);
        assertEquals(UnifiedMap.newWithKeysValues('z', "zero", 'o', "one", 't', "two"), map1.groupByUniqueKey(firstChar));
        assertEquals(UnifiedMap.newWithKeysValues('t', "two"), map2.groupByUniqueKey(firstChar));
    }

    @Test
    public void groupByUniqueKey_throws()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        Function\<String, Character> firstChar = (String object) -> 'a';
        assertThrows(IllegalStateException.class, () -> map1.groupByUniqueKey(firstChar));
    }

    @Test
    public void groupByUniqueKey_target()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("0")>, "zero");
        Function\<String, Character> firstChar = (String object) -> object.charAt(0);
        assertEquals(UnifiedMap.newWithKeysValues('z', "zero", 'o', "one", 't', "two"), map1.groupByUniqueKey(firstChar, UnifiedMap.newWithKeysValues('t', "two")));
        assertEquals(UnifiedMap.newWithKeysValues('z', "zero", 't', "two"), map2.groupByUniqueKey(firstChar, UnifiedMap.newWithKeysValues('t', "two")));
    }

    @Test
    public void groupByUniqueKey_target_throws_1()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        Function\<String, Character> firstChar = (String object) -> object.charAt(0);
        assertThrows(IllegalStateException.class, () ->
                map1.groupByUniqueKey(firstChar, UnifiedMap.newWithKeysValues('z', "zero")));
    }

    @Test
    public void groupByUniqueKey_target_throws_2()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero");
        Function\<String, Character> firstChar = (String object) -> object.charAt(0);
        assertThrows(IllegalStateException.class, () ->
                map1.groupByUniqueKey(firstChar, UnifiedMap.newWithKeysValues('z', "zero")));
    }

    @Test
    public void groupByUniqueKey_target_throws_3()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("2")>, "two");
        Function\<String, Character> firstChar = (String object) -> object.charAt(0);
        assertThrows(IllegalStateException.class, () ->
                map1.groupByUniqueKey(firstChar, UnifiedMap.newWithKeysValues('t', "two")));
    }

    @Test
    public void makeString()
    {
        assertEquals("", this.getEmptyMap().makeString());
        assertEquals("zero", this.newWithKeysValues(<(literal.(type))("0")>, "zero").makeString());
        assertEquals("one", this.newWithKeysValues(<(literal.(type))("1")>, "one").makeString());
        assertEquals("five", this.newWithKeysValues(<(literal.(type))("5")>, "five").makeString());

        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        assertTrue(
                "zero, one".equals(map1.makeString())
                        || "one, zero".equals(map1.makeString()), map1.makeString());

        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        assertTrue(
                "[one/thirtyTwo]".equals(map2.makeString("[", "/", "]"))
                        || "[thirtyTwo/one]".equals(map2.makeString("[", "/", "]")), map2.makeString("[", "/", "]"));

        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("32")>, "thirtyTwo");
        assertTrue(
                "zero~thirtyTwo".equals(map3.makeString("~"))
                        || "thirtyTwo~zero".equals(map3.makeString("~")), map3.makeString("~"));

        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo", <(literal.(type))("33")>, "thirtyThree");
        assertTrue(
                "[thirtyTwo, thirtyThree]".equals(map4.makeString("[", ", ", "]"))
                        || "[thirtyThree, thirtyTwo]".equals(map4.makeString("[", ", ", "]")), map4.makeString("[", ", ", "]"));
    }

    @Test
    public void appendString()
    {
        Appendable appendable = new StringBuilder();
        this.getEmptyMap().appendString(appendable);
        assertEquals("", appendable.toString());

        Appendable appendable0 = new StringBuilder();
        this.newWithKeysValues(<(literal.(type))("0")>, "zero").appendString(appendable0);
        assertEquals("zero", appendable0.toString());

        Appendable appendable1 = new StringBuilder();
        this.newWithKeysValues(<(literal.(type))("1")>, "one").appendString(appendable1);
        assertEquals("one", appendable1.toString());

        Appendable appendable2 = new StringBuilder();
        this.newWithKeysValues(<(literal.(type))("5")>, "five").appendString(appendable2);
        assertEquals("five", appendable2.toString());

        Appendable appendable3 = new StringBuilder();
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        map1.appendString(appendable3);
        assertTrue(
                "zero, one".equals(appendable3.toString())
                        || "one, zero".equals(appendable3.toString()), appendable3.toString());

        Appendable appendable4 = new StringBuilder();
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        map2.appendString(appendable4, "[", "/", "]");
        assertTrue(
                "[one/thirtyTwo]".equals(appendable4.toString())
                        || "[thirtyTwo/one]".equals(appendable4.toString()), appendable4.toString());

        Appendable appendable5 = new StringBuilder();
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        map3.appendString(appendable5, "[", "/", "]");
        assertTrue(
                "[one/thirtyTwo]".equals(appendable5.toString())
                        || "[thirtyTwo/one]".equals(appendable5.toString()), appendable5.toString());

        Appendable appendable6 = new StringBuilder();
        map3.appendString(appendable6, "/");
        assertTrue(
                "one/thirtyTwo".equals(appendable6.toString())
                        || "thirtyTwo/one".equals(appendable6.toString()), appendable6.toString());
    }

    @Test
    public void tap()
    {
        StringBuilder[] concat = new StringBuilder[4];
        concat[0] = new StringBuilder();
        concat[1] = new StringBuilder();
        concat[2] = new StringBuilder();
        concat[3] = new StringBuilder();

        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");

        assertSame(map1, map1.tap(concat[0]::append));
        assertSame(map2, map2.tap(concat[1]::append));
        assertSame(map3, map3.tap(concat[2]::append));
        assertSame(map4, map4.tap(concat[3]::append));

        assertTrue("onefive".equals(concat[0].toString()) || "fiveone".equals(concat[0].toString()), concat[0].toString());
        assertTrue("onezero".equals(concat[1].toString()) || "zeroone".equals(concat[1].toString()), concat[1].toString());
        assertTrue("twofive".equals(concat[2].toString()) || "fivetwo".equals(concat[2].toString()), concat[2].toString());
        assertTrue("zerofive".equals(concat[3].toString()) || "fivezero".equals(concat[3].toString()), concat[3].toString());
    }

    @Test
    public void forEach()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        String[] concat = {"", "", "", ""};

        map1.forEach(Procedures.cast(each -> concat[0] += each));
        map2.forEach(Procedures.cast(each -> concat[1] += each));
        map3.forEach(Procedures.cast(each -> concat[2] += each));
        map4.forEach(Procedures.cast(each -> concat[3] += each));

        assertTrue("onefive".equals(concat[0]) || "fiveone".equals(concat[0]), concat[0]);
        assertTrue("onezero".equals(concat[1]) || "zeroone".equals(concat[1]), concat[1]);
        assertTrue("twofive".equals(concat[2]) || "fivetwo".equals(concat[2]), concat[2]);
        assertTrue("zerofive".equals(concat[3]) || "fivezero".equals(concat[3]), concat[3]);
    }

    @Test
    public void forEachWithIndex()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        String[] concat = {"", "", "", ""};

        map1.forEachWithIndex((String each, int parameter) ->
        {
            concat[0] += each;
            concat[0] += parameter;
        });
        map2.forEachWithIndex((String each, int parameter) ->
        {
            concat[1] += each;
            concat[1] += parameter;
        });
        map3.forEachWithIndex((String each, int parameter) ->
        {
            concat[2] += each;
            concat[2] += parameter;
        });
        map4.forEachWithIndex((String each, int parameter) ->
        {
            concat[3] += each;
            concat[3] += parameter;
        });

        assertTrue("one0five1".equals(concat[0]) || "five0one1".equals(concat[0]), concat[0]);
        assertTrue("one0zero1".equals(concat[1]) || "zero0one1".equals(concat[1]), concat[1]);
        assertTrue("two0five1".equals(concat[2]) || "five0two1".equals(concat[2]), concat[2]);
        assertTrue("zero0five1".equals(concat[3]) || "five0zero1".equals(concat[3]), concat[3]);
    }

    @Test
    public void forEachWith()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        <name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        <name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        String[] concat = {"", "", "", ""};

        map1.forEachWith((String argument1, String argument2) ->
        {
            concat[0] += argument1;
            concat[0] += argument2;
        }, "-");
        map2.forEachWith((String argument1, String argument2) ->
        {
            concat[1] += argument1;
            concat[1] += argument2;
        }, "-");
        map3.forEachWith((String argument1, String argument2) ->
        {
            concat[2] += argument1;
            concat[2] += argument2;
        }, "-");
        map4.forEachWith((String argument1, String argument2) ->
        {
            concat[3] += argument1;
            concat[3] += argument2;
        }, "-");

        assertTrue("one-five-".equals(concat[0]) || "five-one-".equals(concat[0]), concat[0]);
        assertTrue("one-zero-".equals(concat[1]) || "zero-one-".equals(concat[1]), concat[1]);
        assertTrue("two-five-".equals(concat[2]) || "five-two-".equals(concat[2]), concat[2]);
        assertTrue("zero-five-".equals(concat[3]) || "five-zero-".equals(concat[3]), concat[3]);
    }

    @Test
    public void iterator()
    {
        MutableSet\<String> expected = UnifiedSet.newSetWith("zero", "thirtyOne", "thirtyTwo");
        MutableSet\<String> actual = UnifiedSet.newSet();

        Iterator\<String> iterator = this.classUnderTest().iterator();
        assertTrue(iterator.hasNext());
        actual.add(iterator.next());
        assertTrue(iterator.hasNext());
        actual.add(iterator.next());
        assertTrue(iterator.hasNext());
        actual.add(iterator.next());
        assertFalse(iterator.hasNext());

        assertEquals(expected, actual);
        assertThrows(NoSuchElementException.class, iterator::next);
    }

    @Test
    public void toImmutable()
    {
        assertEquals(this.classUnderTest(), this.classUnderTest().toImmutable());
        Verify.assertInstanceOf(Immutable<name>ObjectMap.class, this.classUnderTest().toImmutable());
    }

    @Test
    public void toSortedBag()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        <name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");

        Verify.assertSortedBagsEqual(TreeBag.newBagWith("zero", "zero", "nine"), map1.toSortedBag());
        Verify.assertSortedBagsEqual(TreeBag.newBagWith(Comparator.reverseOrder(), "one", "one", "nine"), map2.toSortedBag(Comparator.\<String>reverseOrder()));
    }

    @Test
    public void toSortedBagBy()
    {
        <name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");

        Verify.assertSortedBagsEqual(TreeBag.newBagWith(Comparators.byFunction(String::valueOf), "zero", "zero", "nine"), map1.toSortedBagBy(String::valueOf));
    }

    @Test
    public void stream()
    {
        <name>ObjectMap\<String> map = this.newWithKeysValues(<(literal.(type))("1")>, "1", <(literal.(type))("2")>, "2", <(literal.(type))("9")>, "9");
        assertEquals("129", CharAdapter.adapt(map.stream().reduce("", (r, s) -> r + s)).toSortedList().makeString(""));
        assertEquals(map.reduce((r, s) -> r + s), map.stream().reduce((r, s) -> r + s));
    }

    @Test
    public void parallelStream()
    {
        <name>ObjectMap\<String> map = this.newWithKeysValues(<(literal.(type))("1")>, "1", <(literal.(type))("2")>, "2", <(literal.(type))("9")>, "9");
        assertEquals("129", CharAdapter.adapt(map.parallelStream().reduce("", (r, s) -> r + s)).toSortedList().makeString(""));
        assertEquals(map.reduce((r, s) -> r + s), map.stream().reduce((r, s) -> r + s));
    }
}

>>
